We chose to use a **document-based** data model for our web app because we only have one entity to store data for - the user. All the objects from the Microsoft Azure Face API called for each specific user can be conveniently stored as nested objects inside the overarching User JSON object. On the other hand, a relational data model would allow for a higher degree of normalization (e.g. instead of storing the same face attribute value for multiple users, we would just store it once and record the users associated with it). However, we did not think it would improve performance significantly enough to trade it for simplicity in the scale of our app.

We have not yet implemented a data store for our web app, but you can see in our planned [JSON schema](/CS411 A3 Team3 - JSON Schema) what information we plan to store for each user. To walk you through the schema, for each user we want to store their unique user ID (i.e. the Facebook email), the URL of the image they upload or the image object itself (TBD), and the following objects returned by the Face API: faceRectangle, faceLandmarks, faceAttributes. We are calling and storing the values of all attributes from faceRectangle, all attributes from faceLandmarks, and only 2 attributes from faceAttributes (full Face API documentation [here](https://westus.dev.cognitive.microsoft.com/docs/services/563879b61984550e40cbbe8d/operations/563879b61984550f30395236)). The reason we do not need all of them is that some of them contain information irrelevant (e.g. smile, emotion) for training our ML model for matching face types with glasses types. We are only looking for the ones that give us information about the user's face measurements, age and gender.

As for our [sequence diagram](/CS411 A3 Team3 - Sequence Diagram), it follows 2 different paths depending on what is input by the user into the web application: (1) new picture/URL upload or (2) retrieval code input.
Because we want to check if a picture or picture URL has already been uploaded/input in the past, we would want to check the cache to see if our database already has the relevant data connected to the picture. However, it is incredibly difficult to check equality for pictures, if we could even cache the picture itself. Thus, for our first path, we now assume that any picture/URL that is input is new and will not be in the database. With this path, we will always make the API call for data on the picture given. Then we generate a random code that will act as a retrieval code (explained below), store all the data in the database (along with the retrieval code), and cache the retrieval code. Finally, the relevant information will be displayed back on the website for the user to see.

The second path involves the retrieval code mentioned above. Again, because it is difficult to check equality on pictures, we will use the code instead. This path assumes that the user has uploaded a picture/URL in the past and has been given a retrieval code. The user inputs their retrieval code, and the system will check if it is in the cache. If it is, then it will get the relevant data associated with the retrieval code (without any API call) and then it will display the relevant data back to the user.
